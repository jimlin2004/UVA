#include <bits/stdc++.h>
using namespace std;

/*
    題意:
        去銀行領一筆金額X，想讓找錢的種類越多越好
        (找錢使用貪心，盡量給大面額的貨幣)
*/

// 貨幣種類(由小到大給定)
long long C[1005];

int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        int n;
        scanf("%d", &n);

        for (int i = 0; i < n; ++i)
            scanf("%lld", &C[i]);
        
        /*
            貪心解法:
            1. 最大的面額C[n - 1]一定會拿
            反證法: 因為如果領了sum元卻沒有拿C[n - 1]，則存在sum + C[n - 1]可以多拿一種面額
            2. 假設S(i)是C[1] ~ C[i]中被選重的貨幣面額的值，則一定S(i) < C[i + 1]
            反證法: 因為若出現S(i) >= C[i + 1]，則銀行的行員一定是給C[i + 1]的面額貨幣，
                    此時獲得的種類只會變少或不變
            
            所以可以建構出一個序列
            當S(i - 1) < C[i] && S(i) = S(i - 1) + C[i] < C[i + 1]
            則C[i]會被選中
            
            
            感性的說明:
            如果目前收集的硬幣總和是sum，考慮要不要拿C[i]，
            則如果拿了C[i]，則總和變成sum + C[i]，
            此時如果sum + C[i] >= C[i + 1]，則銀行員會直接用C[i + 1]的貨幣取代之前的小貨幣(包含C[i])
            ，所以貨幣只會變少或不變，不如不拿，去考慮下一個貨幣

            然後最大貨幣必拿就不用講了

            至於最小的為什麼要拿
            是因為最小的幣值不會導致前面收集的變小，所以可以先拿一個
            (而且這題說C[0]一定是1)
        */
        
        int res = 2;
        long long sum = C[0];
        for (int i = 1; i < n - 1; ++i)
        {
            if (sum < C[i] && sum + C[i] < C[i + 1])
            {
                sum += C[i];
                ++res;
            }
        }
        printf("%d\n", res);
    }

    return 0;
}