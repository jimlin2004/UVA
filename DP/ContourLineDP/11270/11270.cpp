#include <bits/stdc++.h>
using namespace std;

/*
    狀壓dp加上輪廓線dp

    首先利用bits的0、1當作該格子是否有放骨牌
    這樣就可以使用狀態壓縮枚舉所有狀態

    這題輸入n * m <= 100，只要處理m永遠是比較小的邊
    這樣能保證m <= 10，能保證時間複雜度

    每個格子有不放、直著放、橫著放三種選擇
    為了保證dp只由過去的狀態得來，所以枚舉格子當作骨牌的底部的可能
    用4 * 4的情況討論
    當前是(x代表0 或 1，k是目前討論的，?是還沒討論到)
    x x x x
    x k ? ?
    ? ? ? ?
    ? ? ? ?
    
    k不放:
    x x x x
    x 0 ? ?
    ? ? ? ?
    ? ? ? ?

    k直著放
    x 1 x x
    x 1 ? ?
    ? ? ? ?
    ? ? ? ?

    k橫著放
    x x x x
    1 1 ? ?
    ? ? ? ?
    ? ? ? ?

    可以發現到
    k放不放會需要知道能不能放
    要知道能不能放需要知道k3、k2、k1、k0的狀態
    x  k3 k2 k1
    k0 k  ?  ?
    ?  ?  ?  ?
    ?  ?  ?  ?

    因此會需要維護 k3、k2、k1、k0，且不同位置所有不同
    但總歸都是前m個bits
    這樣的需求需要利用輪廓線dp維護

    情況一(不放):
    x  k3 k2 k1            x  x  k2 k1
    k0 k  ?  ?      ->     k0 0  ?  ? 
    ?  ?  ?  ?             ?  ?  ?  ?
    ?  ?  ?  ?             ?  ?  ?  ?
    輪廓線從 k3 k2 k1 k0 變成 k2 k1 k0 k[=0]

    情況二(直放):
    x  0  k2 k1            x  1  k2 k1
    k0 k  ?  ?      ->     k0 1  ?  ?
    ?  ?  ?  ?             ?  ?  ?  ?
    ?  ?  ?  ?             ?  ?  ?  ?
    k3那格一定要是0，不然k不能直放
    輪廓線從 k3[=0] k2 k1 k0 變成 k2[=1] k1 k0 k[=1]

    情況三(橫放):
    x  k3 k2 k1            x  x  k2 k1
    0  k  ?  ?      ->     1  1  ?  ?
    ?  ?  ?  ?             ?  ?  ?  ?
    ?  ?  ?  ?             ?  ?  ?  ?
    k0那格一定要是0，不然k不能橫放
    輪廓線從 k3 k2 k1 k0[=0] 變成 k2 k1 k0[=1] k[=1]

    上面詳細可看(推導1.png)

    由於需要枚舉k的位置以及輪廓線的狀態，所以時間複雜度為 O(2^m * m * n)
    因為限制m永遠最小，如此m <= 10，所以複雜度是1e5等級的

    狀態轉移看下方

*/


// maxn設成15會超時，11就可以(因為有大量的memset)
#define maxn 11

int n, m;
int curr; // dp空間壓縮
long long dp[2][1 << maxn];


inline void update(int s1, int s2)
{
    if (s2 & (1 << m)) // 檢查當前輪廓線的更前面一格bit是否為1，若為0是非法狀態(因為那一格如果沒放，我無論怎麼放都不能改變它)
        dp[curr][s2 ^ (1 << m)] += dp[1 - curr][s1]; // s2 ^ (1 << m)只是為了清掉那個bit，因為只需要輪廓線的bits範圍即可
}


int main()
{
    while (scanf("%d %d", &n, &m) != EOF)
    {
        if (n < m) // 讓m永遠比較小，這樣可以保證時間複雜度
            swap(n, m);

        memset(dp, 0, sizeof(dp));
        dp[0][(1 << m) - 1] = 1; // 初始狀態，在邊界全部都是1，也就是都有骨牌
        curr = 0;

        // 枚舉所有格子當作骨牌的底部
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < m; ++j)
            {
                curr = 1 - curr; // 空間壓縮轉換
                memset(dp[curr], 0, sizeof(dp[curr]));

                for (int k = 0; k < (1 << m); ++k) // 枚舉所有輪廓線狀態
                {
                    update(k, k << 1); // 不放
                    if (i && !(k & (1 << m - 1))) // 直著放
                        update(k, (k << 1) | (1 << m) | 1); // 由上面的推導可知輪廓線頭跟當前位置會放骨牌，所以設成1(用or 1)
                    if (j && !(k & 1)) // 橫著放
                        update(k, (k << 1) | 3); // 由上面推導可知輪廓線的最後一格與當前位置會放骨牌，所以設成1(用or 3)
                }
            }
        }

        printf("%lld\n", dp[curr][(1 << m) - 1]); // 答案在全滿的狀態裡
    }

    return 0;
}