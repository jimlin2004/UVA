#include <cstdio>
#include <cmath>

//數學題

/*
題目規定頭尾要是1
每一步只能是上一步的-1、不變、+1
觀察
0步最多到 0
1步最多到 1  -> 1               + 1
2步最多到 2  -> 1 1             + 1
3步最多到 4  -> 1 2 1           + 2
4步最多到 6  -> 1 2 2 1         + 2
5步最多到 9  -> 1 2 3 2 1       + 3
6步最多到 12 -> 1 2 3 3 2 1     + 3
7步最多到 16 -> 1 2 3 4 3 2 1   + 4
8步最多到 20 -> 1 2 3 4 4 3 2 1 + 4
...

用找到的兩種規律推公式

1 2 3 ... (n - 1) n (n - 1) .. 3 2 1
=> [(1 + n - 1) * (n - 1)] / 2 * 2 + n
=> n ^ 2 - n + n = n ^ 2
所以距離 n ^ 2 需要 n + (n - 1)步

1 2 3 ... (n - 1) n n (n - 1) ... 3 2 1
=> [(1 + n) * n] / 2 * 2
=> n ^ 2 + n
所以距離 n ^ 2 + n 需要2n步

距離5 -> 1 1 2 1   -> sqrt(5) = 2 -> 5 > n ^ 2     -> 要2 * n步
距離7 -> 1 2 2 1 1 -> sqrt(7) = 2 -> 7 > n ^ 2 + n -> 要2 * n + 1步
距離8 -> 1 2 2 2 1 -> sqrt(8) = 2 -> 8 > n ^ 2 + n -> 要2 * n + 1步
...
距離k (n ^ 2 < k < n ^ 2 + n)
需要的步數會是2 * n步
距離k (n ^ 2 + n < k)
需要的步數會是2 * n + 1步
至此推完公式。


網路上找到另一種解法是用觀察到的
steps 最大可到的距離 increase
0     0
1     1             +1
2     2             +1
3     4             +2
4     6             +2
5     9             +3
6     12            +3
7     16            +4
8     20            +4
...
步數與距離的關係為
f(2n)     = n(n + 1)
f(2n + 1) = (n + 1) ^ 2
找到反函數 f^-1(n) = ceil(sqrt(4n) - 1)
即可O(1)解決這題。
*/

int main()
{
    int a, b;
    int t;
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d %d", &a, &b);
        int dis = b - a;
        if (dis <= 3)
            printf("%d\n", dis);
        else
        {
            int n = sqrt(dis);
            if (n * n == dis)
            {
                printf("%d\n", 2 * n - 1);
            }
            else if (n * n + n == dis)
            {
                printf("%d\n", 2 * n);
            }
            else if (n * n < dis && dis < n * n + n)
            {
                printf("%d\n", 2 * n);
            }
            else
            {
                printf("%d\n", 2 * n + 1);
            }
        }
    }
    return 0;
}