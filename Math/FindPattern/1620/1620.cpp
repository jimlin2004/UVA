#include <bits/stdc++.h>
using namespace std;


/*

數學結論題

定義 逆序數
    1 3 2 4 6 5 7 8 的逆序數
->  0+1+0+0+1+0+0+0 = 2
也就是每個數字後面有多少的數字比自己小

討論4個數字反轉對逆序數的改變
假設4個數字翻轉前逆序數是x，則翻轉後的逆序數是6 - x
為什麼
假設4個數字的逆序數: a + b + c + d = x，d一定等於0 -> a + b + c = x
經過翻轉
(3 - a) + (2 - b) + (1 - c) = 6 - (a + b + c) = 6 - x
其中逆序數的變化是
(6 - x) - x = 6 - 2x -> 一定是偶數的變化量

之後是一個通靈的部分，需要數學證明(我查不到)
1. 由於是循環的，只要逆序數是偶數，由於翻轉的變化量是增或減偶數變化量，一定可以找到排好的排列(不清楚原理)
1. 若原本的N是偶數，他的逆序數一定是偶數(包含0)
2. 若N是奇數，此時逆序數可能是偶數或奇數，偶數的一樣可以透過翻轉得到排好的，
但若是奇數，無法透過翻轉讓排好(因為變化量是偶數，奇數 +- 偶數還是奇數)

*/


#define maxn 505

int A[maxn];

int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        int n;
        scanf("%d", &n);
    
        for (int i = 0; i < n; ++i)
            scanf("%d", &A[i]);
        
        int cnt = 0; // 逆序數

        for (int i = 0; i < n; ++i)
        {
            for (int j = i + 1; j < n; ++j)
            {
                if (A[i] > A[j])
                    ++cnt;
            }
        }

        if (n % 2 == 1 && cnt % 2 == 1) // N奇數且逆序數奇數 -> 不可能
            puts("impossible");
        else
            puts("possible");
    }

    return 0;
}